# 성능 최적화 - 2

앞서 `memo()`, `useMemo()`를 사용하지 않고 성능을 최적화할 수 있는 방법을 살펴봤다.

제시된 2가지 솔루션은 다음과 같은 키워드로 분류할 수 있다.

## State Colocation

> 코드를 최대한 그것과 연관있는 곳에 배치 시켜라

왜 `useMemo()`, `memo()`를 마치 피하는 것처럼 느껴질까. 분명 이 함수들은 

성능 최적화를 위해 사용할 수 있는 중요한 함수이고, 실제로 온갖 예제, 앞선 주차의 `Expensive Tree`에서 잘 동작한다.

하지만 문제는 다른 곳에 있다. 현실세계의 Application에선 렌더링을 방해하는게 한두가지 요소가 아니다. 

이 말은 `colocation` 원칙을 배제한채 진행한 성능최적화(memo)는 되레 끔찍한 비용을 발생시킬 것이다.

비지니스요구는 증가하고 복잡해지기 때문이다. 그말은 **모든 곳에서 useMemo, useCallback, memo**를 써야할 수도 있음을 의미한다.

한줄의 코드를 추가하기위해 2~3줄의 코드를 써야한다. 위 함수들로 래핑하는 부분과, 의존성 배열 주입부분만 해도 2줄이다.

`memo()`의 경우는 업데이트를 결정해주는 콜백함수까지 추가 하게 되서 3~4줄이 추가될 수 있다.(if statement...)

결국 리액트는 여전히 최상단에서 최말단 컴포넌트에 이르기까지, 모든 컴포넌트에서 리렌더링을 해야할지를 결정해야 한다. 

## 그래도 그냥 쓰면 안되나?

결국 이러한 접근(colocate을 고려하지 않고 모든 부분을 찾아 최적화하는)으로 코드를 더더 작성할수록 더더더더더더더 힘들어 질것이다.

물론 "동작하기만 한다면 그냥 쓸 수도 있지 않나?" 싶지만 

> 코드를 더 쓴다 === 프로그래머가 개입한다 === 버그가 늘어날 가능성 증가 === 앱 신뢰도 저하

이런 현실적인 문제를 키우게 될것이다.

이와 관련해서 https://overreacted.io/ko/the-bug-o-notation/

글을 소개하고 싶다. `Bug O notation`이라는 재밌는 표현이 압권이다.(성능 최적화와는 관련 없지만)

---

**Reference**

https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster